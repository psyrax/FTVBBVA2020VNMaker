// Generated by CoffeeScript 1.12.7
(function() {
  var SceneManager,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SceneManager = (function(superClass) {
    extend(SceneManager, superClass);


    /**
    * Manages the scenes of the game.
    *
    * @module gs
    * @class SceneManager
    * @memberof gs
    * @constructor
     */

    function SceneManager() {
      SceneManager.__super__.constructor.apply(this, arguments);

      /**
      * The current scene.
      * @property scene
      * @type gs.Object_Base
       */
      this.scene = null;

      /**
      * An array of previous scenes. Used to jump back to last scene from a menu for example.
      * @property previousScenes
      * @type gs.Object_Base
       */
      this.previousScenes = [];

      /**
      * The next scene. If set, this scene will become the current scene after next update.
      * @property nextScene
      * @type gs.Object_Base
       */
      this.nextScene = null;

      /**
      * The transition-data like the graphic, vague, etc. used for a transition from one scene to another.
      * @property transitionData
      * @type Object
       */
      this.transitionData = {
        graphic: null,
        duration: 20,
        vague: 30
      };
      this.input = true;

      /**
      * Called if a scene-change has been done.
      * @property callback
      * @type Function
       */
      this.callback = null;
      this.paused = false;
    }

    SceneManager.prototype.initialize = function() {};


    /**
    * Switches from the current scene to the specified one.
    *
    * @method switchTo
    * @param {gs.Object_Base} scene - The new scene.
    * @param {boolean} savePrevious - Indicates if the current scene should be pushed to previous-scene stack instead
    * of getting disposed. It is possible to switch back to that scene then using gs.SceneManager.returnToPrevious method.
    * @param {Function} callback - Called after the scene has been changed.
     */

    SceneManager.prototype.switchTo = function(scene, savePrevious, callback) {
      this.callback = callback;
      if (savePrevious) {
        this.previousScenes.push(this.scene);
      } else if (this.previousScenes.length === 0) {
        gs.Audio.reset();
      }
      if (this.scene != null) {
        this.removeObject(this.scene);
      }
      this.nextScene = scene;
      return Graphics.freeze();
    };


    /**
    * Clears the stack of previous-scenes and disposes all previous-scenes. After that it is not
    * possible to go back to a previous scene using gs.SceneManager.returnToPrevious().
    *
    * @method clear
     */

    SceneManager.prototype.clear = function() {
      var i, len, ref, scene;
      ref = this.previousScenes;
      for (i = 0, len = ref.length; i < len; i++) {
        scene = ref[i];
        scene.dispose();
      }
      return this.previousScenes = [];
    };


    /**
    * Returns to the previous scene if that scene was saved before.
    *
    * @method returnToPrevious
    * @param {Function} callback - Called after the scene has been changed.
     */

    SceneManager.prototype.returnToPrevious = function(callback) {
      var scene;
      this.callback = callback;
      if (this.previousScenes.length > 0) {
        scene = this.previousScenes.pop();
        if (this.scene != null) {
          this.removeObject(this.scene);
        }
        if (scene != null) {
          this.nextScene = scene;
          return Graphics.freeze();
        }
      }
    };


    /**
    * Updates the current scene and the scene-handling. Needs to be called once
    * per frame.
    *
    * @method update
     */

    SceneManager.prototype.update = function() {
      var ref;
      if (this.nextScene !== this.scene) {
        Input.clear();
        if (this.scene != null) {
          if (this.previousScenes.indexOf(this.scene) === -1) {
            this.scene.dispose();
          } else {
            this.scene.behavior.show(false);
          }
        }
        this.scene = this.nextScene;
        if (typeof this.callback === "function") {
          this.callback();
        }
        if (this.scene) {
          this.addObject(this.scene);
          this.scene.loading = true;
          this.scene.loadingData = true;
          this.scene.loadingResources = true;
          if ((this.scene != null) && !this.scene.initialized) {
            this.scene.behavior.initialize();
            this.scene.behavior.prepareLoadingScreen();
            this.isFadeOut = true;
          } else if ((ref = this.scene) != null ? ref.initialized : void 0) {
            this.scene.behavior.show(true);
            this.scene.update();
          }
          Graphics.update();
          this.scene.behavior.transition();
        } else {
          Graphics.freeze();
          Graphics.update();
          Graphics.transition(30);
          this.isFadeOut = true;
        }
      }
      if (this.isFadeOut && Graphics.frozen) {
        Graphics.update();
        return Input.update();
      } else {
        if (this.isFadeOut) {
          AudioManager.stopAllSounds();
          this.isFadeOut = false;
          if (this.scene) {
            Graphics.freeze();
          } else {
            gs.Application.exit();
          }
        }
        DataManager.update();
        ResourceManager.update();
        if (RecordManager.initialized) {
          AudioManager.update();
        }
        if (Graphics.frozen) {
          Input.update();
        }
        return SceneManager.__super__.update.call(this);
      }
    };

    return SceneManager;

  })(gs.ObjectManager);

  window.SceneManager = new SceneManager();

  gs.SceneManager = window.SceneManager;

}).call(this);
