{
    "uid": "8DBB050CK548EA49A5S800AE8C9C8A84C8B9",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "ObjectManager",
        "type": "game_script",
        "order": 0,
        "parentId": "C0268943K60B3A42B7SA6F1EDDCF2F642FD7",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: ObjectManager\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass ObjectManager\n    ###*\n    * Stores the current default ObjectManager.\n    * @property current\n    * @type gs.ObjectManager\n    * @static\n    ### \n    @current: null\n    \n    ###*\n    * Manages game objects by updating if necessary and offering\n    * methods to add or remove game objects. All game objects are sorted by\n    * the order-property to give control over the update-order.\n    *\n    * A game object can registered under a unique ID and then easily accessed using\n    * that ID. If an object gets registered, a global variable $<ID> is created\n    * as well. However, that global variable is only for the use in property-bindings\n    * used for In-Game UI. See ui.Component_BindingHandler.\n    *\n    * In addition, a game object can be assigned to a group like for example\n    * a set of UI toggle-buttons can be assigned to the same group and then\n    * easily accessed later using gs.ObjectManager.objectsByGroup method.\n    *\n    * @module gs\n    * @class ObjectManager\n    * @memberof gs\n    * @constructor\n    * @see ui.Component_BindingHandler\n    ###\n    constructor: ->\n        ###*\n        * All game objects to manage.\n        * @property objects\n        * @type gs.Object_Base[]\n        ### \n        @objects = []\n        \n        ###*\n        * All game objects by ID.\n        * @property objectsById\n        * @type Object\n        ### \n        @objectsById = {}\n        \n        ###*\n        * All game objects by group.\n        * @property objectsByGroup_\n        * @type Object\n        ### \n        @objectsByGroup_ = {}\n        \n        ###*\n        * Indicates if the ObjectManager is active. If <b>false</b> the game objects are not updated.\n        * @property active\n        * @type boolean\n        ### \n        @active = yes\n        \n        ###*\n        * Indicates if the ObjectManager needs to sort the game objects.\n        * @property active\n        * @type boolean\n        ### \n        @needsSort = yes\n        \n    ###*\n    * Disposes the manager and all assigned game objects.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        for object in @objects\n            if not object.disposed\n                object.dispose()\n     \n    ###*\n    * Disposes all assigned game objects.\n    *\n    * @method disposeObjects\n    ###           \n    disposeObjects: ->\n        keys = Object.keys(@objectsById)\n        for k in keys\n            object = @objectsById[k]\n            if object and not object.disposed\n                object.dispose()\n    \n    ###*\n    * Registers an object.\n    *\n    * @method registerObject\n    ###\n    registerObject: (object) ->\n        if object.id?\n            if !@objectsById[object.id]\n                @objectsById[object.id] = []\n            @objectsById[object.id].push(object)\n            # FIXME: Should be handled by UiManager since it is UI specific.\n            window[\"$\"+object.id] = object\n    \n    ###*\n    * Unregisters an object.\n    *\n    * @method unregisterObject\n    ###        \n    unregisterObject: (object) ->\n        if object?.id?\n            objects = @objectsById[object.id]\n            if objects\n                objects.remove(object)\n                if objects.length > 0\n                    window[\"$\"+object.id] = objects.last()\n                else\n                    delete window[\"$\"+object.id]\n        return null\n    \n    ###*\n    * Adds a game object to the manager. The game object is then automatically updated by the manager.\n    *\n    * @method addObject\n    * @param {gs.Object_Base} object - The game object to add.\n    ###        \n    addObject: (object) -> @add(object)\n    \n    ###*\n    * Removes a game object to the manager. The game object is then no longer automatically updated or disposed by the manager.\n    *\n    * @method removeObject\n    * @param {gs.Object_Base} object - The game object to remove.\n    ###        \n    removeObject: (object) -> @remove(object)\n    \n    ###*\n    * Adds a game object to the manager. The game object is then automatically updated by the manager.\n    *\n    * @method add\n    * @param {gs.Object_Base} object - The game object to add.\n    ### \n    add: (object) -> \n        #@objects.splice(0, 0, object)\n        @objects.push(object)\n        @needsSort = yes\n        @registerObject(object)\n        @addToGroup(object, object.group)\n        \n    ###*\n    * Removes a game object to the manager. The game object is then no longer automatically updated or disposed by the manager.\n    *\n    * @method remove\n    * @param {gs.Object_Base} object - The game object to remove.\n    ### \n    remove: (object) -> \n        if object\n            @objects.remove(object)\n            @unregisterObject(object)\n            if object.group?\n                @objectsByGroup[object.group]?.remove(object)\n    \n    ###*\n    * Gets an object by ID.\n    *\n    * @method objectById\n    * @param {String} id - The ID of the game object to get. \n    * @return {gs.Object_Base} The game object or <b>null</b> if no game object is registered for the specified ID.\n    ###         \n    objectById: (id) -> @objectsById[id]?.last()\n    \n    ###*\n    * Gets an object by ID.\n    *\n    * @method byId\n    * @param {String} id - The ID of the game object to get. \n    * @return {gs.Object_Base} The game object or <b>null</b> if no game object is registered for the specified ID.\n    ### \n    byId: (id) -> @objectsById[id]?.last()\n    \n    ###*\n    * Sets the object for an ID.\n    *\n    * @method setObjectById\n    * @param {gs.Object_Base} object - The game object to set.\n    * @param {String} id - The ID for the game object. \n    ### \n    setObjectById: (object, id) -> \n        if !id then return\n        \n        object.id = id\n        if !@objectsById[id]\n            @objectsById[id] = [object]\n        else\n            @objectsById[id].push(object)\n            \n        window[\"$\"+id] = object\n    \n    ###*\n    * Adds an object to a specified object-group.\n    *\n    * @method addToGroup\n    * @param {gs.Object_Base} object - The game object to add.\n    * @param {String} group - The group to assign game object to. \n    ### \n    addToGroup: (object, group) ->\n        if group?\n            @objectsByGroup_[object.group]?.remove(object)\n            if !@objectsByGroup_[group]\n                @objectsByGroup_[group] = []\n            @objectsByGroup_[group].push(object)\n    \n    ###*\n    * Gets all object of a specified object-group.\n    *\n    * @method objectsByGroup\n    * @param {String} group - The object-group.\n    * @return {gs.Object_Base[]} The game objects belonging to the specified group.\n    ###         \n    objectsByGroup: (group) -> @objectsByGroup_[group] || []\n    \n    \n    ###*\n    * Updates the manager and all assigned game objects in the right order.\n    *\n    * @method update\n    ###  \n    update: -> \n        i = 0\n        \n        if @needsSort\n            @objects.sort (a, b) ->\n                if a.order < b.order\n                    return 1\n                else if a.order > b.order\n                    return -1\n                else\n                    return 0\n            @needsSort = no\n                \n        while i < @objects.length\n            object = @objects[i]\n            if object.disposed\n                @removeObject(object)\n            else \n                object.update() if object.active\n                i++\n            \n        return null\n        \ngs.ObjectManager = ObjectManager #new ObjectManager()",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var ObjectManager;\n\n  ObjectManager = (function() {\n\n    /**\n    * Stores the current default ObjectManager.\n    * @property current\n    * @type gs.ObjectManager\n    * @static\n     */\n    ObjectManager.current = null;\n\n\n    /**\n    * Manages game objects by updating if necessary and offering\n    * methods to add or remove game objects. All game objects are sorted by\n    * the order-property to give control over the update-order.\n    *\n    * A game object can registered under a unique ID and then easily accessed using\n    * that ID. If an object gets registered, a global variable $<ID> is created\n    * as well. However, that global variable is only for the use in property-bindings\n    * used for In-Game UI. See ui.Component_BindingHandler.\n    *\n    * In addition, a game object can be assigned to a group like for example\n    * a set of UI toggle-buttons can be assigned to the same group and then\n    * easily accessed later using gs.ObjectManager.objectsByGroup method.\n    *\n    * @module gs\n    * @class ObjectManager\n    * @memberof gs\n    * @constructor\n    * @see ui.Component_BindingHandler\n     */\n\n    function ObjectManager() {\n\n      /**\n      * All game objects to manage.\n      * @property objects\n      * @type gs.Object_Base[]\n       */\n      this.objects = [];\n\n      /**\n      * All game objects by ID.\n      * @property objectsById\n      * @type Object\n       */\n      this.objectsById = {};\n\n      /**\n      * All game objects by group.\n      * @property objectsByGroup_\n      * @type Object\n       */\n      this.objectsByGroup_ = {};\n\n      /**\n      * Indicates if the ObjectManager is active. If <b>false</b> the game objects are not updated.\n      * @property active\n      * @type boolean\n       */\n      this.active = true;\n\n      /**\n      * Indicates if the ObjectManager needs to sort the game objects.\n      * @property active\n      * @type boolean\n       */\n      this.needsSort = true;\n    }\n\n\n    /**\n    * Disposes the manager and all assigned game objects.\n    *\n    * @method dispose\n     */\n\n    ObjectManager.prototype.dispose = function() {\n      var j, len, object, ref, results;\n      ref = this.objects;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        object = ref[j];\n        if (!object.disposed) {\n          results.push(object.dispose());\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Disposes all assigned game objects.\n    *\n    * @method disposeObjects\n     */\n\n    ObjectManager.prototype.disposeObjects = function() {\n      var j, k, keys, len, object, results;\n      keys = Object.keys(this.objectsById);\n      results = [];\n      for (j = 0, len = keys.length; j < len; j++) {\n        k = keys[j];\n        object = this.objectsById[k];\n        if (object && !object.disposed) {\n          results.push(object.dispose());\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Registers an object.\n    *\n    * @method registerObject\n     */\n\n    ObjectManager.prototype.registerObject = function(object) {\n      if (object.id != null) {\n        if (!this.objectsById[object.id]) {\n          this.objectsById[object.id] = [];\n        }\n        this.objectsById[object.id].push(object);\n        return window[\"$\" + object.id] = object;\n      }\n    };\n\n\n    /**\n    * Unregisters an object.\n    *\n    * @method unregisterObject\n     */\n\n    ObjectManager.prototype.unregisterObject = function(object) {\n      var objects;\n      if ((object != null ? object.id : void 0) != null) {\n        objects = this.objectsById[object.id];\n        if (objects) {\n          objects.remove(object);\n          if (objects.length > 0) {\n            window[\"$\" + object.id] = objects.last();\n          } else {\n            delete window[\"$\" + object.id];\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Adds a game object to the manager. The game object is then automatically updated by the manager.\n    *\n    * @method addObject\n    * @param {gs.Object_Base} object - The game object to add.\n     */\n\n    ObjectManager.prototype.addObject = function(object) {\n      return this.add(object);\n    };\n\n\n    /**\n    * Removes a game object to the manager. The game object is then no longer automatically updated or disposed by the manager.\n    *\n    * @method removeObject\n    * @param {gs.Object_Base} object - The game object to remove.\n     */\n\n    ObjectManager.prototype.removeObject = function(object) {\n      return this.remove(object);\n    };\n\n\n    /**\n    * Adds a game object to the manager. The game object is then automatically updated by the manager.\n    *\n    * @method add\n    * @param {gs.Object_Base} object - The game object to add.\n     */\n\n    ObjectManager.prototype.add = function(object) {\n      this.objects.push(object);\n      this.needsSort = true;\n      this.registerObject(object);\n      return this.addToGroup(object, object.group);\n    };\n\n\n    /**\n    * Removes a game object to the manager. The game object is then no longer automatically updated or disposed by the manager.\n    *\n    * @method remove\n    * @param {gs.Object_Base} object - The game object to remove.\n     */\n\n    ObjectManager.prototype.remove = function(object) {\n      var ref;\n      if (object) {\n        this.objects.remove(object);\n        this.unregisterObject(object);\n        if (object.group != null) {\n          return (ref = this.objectsByGroup[object.group]) != null ? ref.remove(object) : void 0;\n        }\n      }\n    };\n\n\n    /**\n    * Gets an object by ID.\n    *\n    * @method objectById\n    * @param {String} id - The ID of the game object to get. \n    * @return {gs.Object_Base} The game object or <b>null</b> if no game object is registered for the specified ID.\n     */\n\n    ObjectManager.prototype.objectById = function(id) {\n      var ref;\n      return (ref = this.objectsById[id]) != null ? ref.last() : void 0;\n    };\n\n\n    /**\n    * Gets an object by ID.\n    *\n    * @method byId\n    * @param {String} id - The ID of the game object to get. \n    * @return {gs.Object_Base} The game object or <b>null</b> if no game object is registered for the specified ID.\n     */\n\n    ObjectManager.prototype.byId = function(id) {\n      var ref;\n      return (ref = this.objectsById[id]) != null ? ref.last() : void 0;\n    };\n\n\n    /**\n    * Sets the object for an ID.\n    *\n    * @method setObjectById\n    * @param {gs.Object_Base} object - The game object to set.\n    * @param {String} id - The ID for the game object.\n     */\n\n    ObjectManager.prototype.setObjectById = function(object, id) {\n      if (!id) {\n        return;\n      }\n      object.id = id;\n      if (!this.objectsById[id]) {\n        this.objectsById[id] = [object];\n      } else {\n        this.objectsById[id].push(object);\n      }\n      return window[\"$\" + id] = object;\n    };\n\n\n    /**\n    * Adds an object to a specified object-group.\n    *\n    * @method addToGroup\n    * @param {gs.Object_Base} object - The game object to add.\n    * @param {String} group - The group to assign game object to.\n     */\n\n    ObjectManager.prototype.addToGroup = function(object, group) {\n      var ref;\n      if (group != null) {\n        if ((ref = this.objectsByGroup_[object.group]) != null) {\n          ref.remove(object);\n        }\n        if (!this.objectsByGroup_[group]) {\n          this.objectsByGroup_[group] = [];\n        }\n        return this.objectsByGroup_[group].push(object);\n      }\n    };\n\n\n    /**\n    * Gets all object of a specified object-group.\n    *\n    * @method objectsByGroup\n    * @param {String} group - The object-group.\n    * @return {gs.Object_Base[]} The game objects belonging to the specified group.\n     */\n\n    ObjectManager.prototype.objectsByGroup = function(group) {\n      return this.objectsByGroup_[group] || [];\n    };\n\n\n    /**\n    * Updates the manager and all assigned game objects in the right order.\n    *\n    * @method update\n     */\n\n    ObjectManager.prototype.update = function() {\n      var i, object;\n      i = 0;\n      if (this.needsSort) {\n        this.objects.sort(function(a, b) {\n          if (a.order < b.order) {\n            return 1;\n          } else if (a.order > b.order) {\n            return -1;\n          } else {\n            return 0;\n          }\n        });\n        this.needsSort = false;\n      }\n      while (i < this.objects.length) {\n        object = this.objects[i];\n        if (object.disposed) {\n          this.removeObject(object);\n        } else {\n          if (object.active) {\n            object.update();\n          }\n          i++;\n        }\n      }\n      return null;\n    };\n\n    return ObjectManager;\n\n  })();\n\n  gs.ObjectManager = ObjectManager;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}